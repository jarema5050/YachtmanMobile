{"ast":null,"code":"import AuthError from \"../auth/authError\";\nimport RSAVerifier from \"./rsa-verifier\";\nimport * as base64 from \"./base64\";\n\nvar jwtDecoder = require('jwt-decode');\n\nvar ALLOWED_ALGORITHMS = ['RS256', 'HS256'];\nexport var verifySignature = function verifySignature(idToken, options) {\n  var header, payload;\n\n  try {\n    header = jwtDecoder(idToken, {\n      header: true\n    });\n    payload = jwtDecoder(idToken);\n  } catch (err) {\n    return Promise.reject(idTokenError({\n      error: 'token_decoding_error',\n      desc: 'ID token could not be decoded'\n    }));\n  }\n\n  var alg = header.alg;\n\n  if (!ALLOWED_ALGORITHMS.includes(alg)) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_algorithm',\n      desc: \"Signature algorithm of \\\"\" + alg + \"\\\" is not supported. Expected \\\"RS256\\\" or \\\"HS256\\\".\"\n    }));\n  }\n\n  if (alg === 'HS256') {\n    return Promise.resolve(payload);\n  }\n\n  return getJwk(options.domain, header.kid).then(function (jwk) {\n    var rsaVerifier = rsaVerifierForKey(jwk);\n    var encodedParts = idToken.split('.');\n    var headerAndPayload = encodedParts[0] + '.' + encodedParts[1];\n    var signature = base64.decodeToHEX(encodedParts[2]);\n\n    if (rsaVerifier.verify(headerAndPayload, signature)) {\n      return Promise.resolve(payload);\n    }\n\n    return Promise.reject(idTokenError({\n      error: 'invalid_signature',\n      desc: 'Invalid ID token signature'\n    }));\n  });\n};\n\nvar rsaVerifierForKey = function rsaVerifierForKey(jwk) {\n  var modulus = base64.decodeToHEX(jwk.n);\n  var exponent = base64.decodeToHEX(jwk.e);\n  return new RSAVerifier(modulus, exponent);\n};\n\nvar getJwk = function getJwk(domain, kid) {\n  return getJwksUri(domain).then(function (uri) {\n    return fetchJson(uri);\n  }).then(function (jwk) {\n    var keys = jwk.keys;\n    var key = keys.filter(function (k) {\n      return k.use === 'sig' && k.kty === 'RSA' && k.kid && k.n && k.e;\n    }).find(function (k) {\n      return k.kid === kid;\n    });\n\n    if (!key) {\n      throw new Error('Key not present');\n    }\n\n    return Promise.resolve(key);\n  }).catch(function (err) {\n    return Promise.reject(idTokenError({\n      error: 'key_retrieval_error',\n      desc: \"Could not find a public key for Key ID (kid) \\\"\" + kid + \"\\\"\"\n    }));\n  });\n};\n\nvar getJwksUri = function getJwksUri(domain) {\n  return fetch(\"https://\" + domain + \"/.well-known/openid-configuration\").then(function (resp) {\n    return resp.json();\n  }).then(function (openIdConfig) {\n    return openIdConfig.jwks_uri;\n  });\n};\n\nvar fetchJson = function fetchJson(uri) {\n  return fetch(uri).then(function (resp) {\n    return resp.json();\n  });\n};\n\nvar idTokenError = function idTokenError(err) {\n  return new AuthError({\n    json: {\n      error: \"a0.idtoken.\" + err.error,\n      error_description: err.desc\n    },\n    status: 0\n  });\n};","map":{"version":3,"sources":["/Users/sokolowski/Documents/Private Repositories/YachtmanMobile/node_modules/react-native-auth0/src/jwt/signatureVerifier.js"],"names":["AuthError","RSAVerifier","base64","jwtDecoder","require","ALLOWED_ALGORITHMS","verifySignature","idToken","options","header","payload","err","Promise","reject","idTokenError","error","desc","alg","includes","resolve","getJwk","domain","kid","then","jwk","rsaVerifier","rsaVerifierForKey","encodedParts","split","headerAndPayload","signature","decodeToHEX","verify","modulus","n","exponent","e","getJwksUri","uri","fetchJson","keys","key","filter","k","use","kty","find","Error","catch","fetch","resp","json","openIdConfig","jwks_uri","error_description","status"],"mappings":"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","sourcesContent":["import AuthError from '../auth/authError';\nimport RSAVerifier from './rsa-verifier';\nimport * as base64 from './base64';\nconst jwtDecoder = require('jwt-decode');\n\nconst ALLOWED_ALGORITHMS = ['RS256', 'HS256'];\n\n/**\n * Verifies that an ID token is signed with a supported algorithm (HS256 or RS256), and verifies the signature\n * if signed with RS256. Note that this function is specific to the internals of this SDK, and not supported for general use.\n * @param {String} idToken the ID token\n * @param {Object} options required to verify an ID token's signature\n * @param {String} [options.domain] the Auth0 domain of the token's issuer\n * @returns {Promise} A promise that resolves to the decoded payload of the ID token, or rejects if the verification fails.\n */\nexport const verifySignature = (idToken, options) => {\n  let header, payload;\n\n  try {\n    header = jwtDecoder(idToken, {header: true});\n    payload = jwtDecoder(idToken);\n  } catch (err) {\n    return Promise.reject(\n      idTokenError({\n        error: 'token_decoding_error',\n        desc: 'ID token could not be decoded',\n      }),\n    );\n  }\n\n  const alg = header.alg;\n\n  if (!ALLOWED_ALGORITHMS.includes(alg)) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_algorithm',\n        desc: `Signature algorithm of \"${alg}\" is not supported. Expected \"RS256\" or \"HS256\".`,\n      }),\n    );\n  }\n\n  // HS256 tokens require private key, which cannot be stored securely in public clients.\n  // Since the ID token exchange is done via CODE with PKCE flow, we can skip signature verification in this case.\n  if (alg === 'HS256') {\n    return Promise.resolve(payload);\n  }\n\n  return getJwk(options.domain, header.kid).then(jwk => {\n    const rsaVerifier = rsaVerifierForKey(jwk);\n    const encodedParts = idToken.split('.');\n    const headerAndPayload = encodedParts[0] + '.' + encodedParts[1];\n    const signature = base64.decodeToHEX(encodedParts[2]);\n    if (rsaVerifier.verify(headerAndPayload, signature)) {\n      return Promise.resolve(payload);\n    }\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_signature',\n        desc: 'Invalid ID token signature',\n      }),\n    );\n  });\n};\n\nconst rsaVerifierForKey = jwk => {\n  const modulus = base64.decodeToHEX(jwk.n);\n  const exponent = base64.decodeToHEX(jwk.e);\n  return new RSAVerifier(modulus, exponent);\n};\n\nconst getJwk = (domain, kid) => {\n  return getJwksUri(domain)\n    .then(uri => fetchJson(uri))\n    .then(jwk => {\n      const keys = jwk.keys;\n      const key = keys\n        .filter(\n          k => k.use === 'sig' && k.kty === 'RSA' && k.kid && (k.n && k.e),\n        )\n        .find(k => k.kid === kid);\n      if (!key) {\n        throw new Error('Key not present');\n      }\n      return Promise.resolve(key);\n    })\n    .catch(err => {\n      return Promise.reject(\n        idTokenError({\n          error: 'key_retrieval_error',\n          desc: `Could not find a public key for Key ID (kid) \"${kid}\"`,\n        }),\n      );\n    });\n};\n\nconst getJwksUri = domain => {\n  return fetch(`https://${domain}/.well-known/openid-configuration`)\n    .then(resp => resp.json())\n    .then(openIdConfig => openIdConfig.jwks_uri);\n};\n\nconst fetchJson = uri => {\n  return fetch(uri).then(resp => resp.json());\n};\n\nconst idTokenError = err => {\n  return new AuthError({\n    json: {\n      error: `a0.idtoken.${err.error}`,\n      error_description: err.desc,\n    },\n    status: 0,\n  });\n};\n"]},"metadata":{},"sourceType":"module"}