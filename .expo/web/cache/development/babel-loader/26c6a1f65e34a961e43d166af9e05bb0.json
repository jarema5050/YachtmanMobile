{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport BaseError from \"./baseError\";\n\nvar ParameterError = function (_BaseError) {\n  _inherits(ParameterError, _BaseError);\n\n  var _super = _createSuper(ParameterError);\n\n  function ParameterError(expected, actual, missing) {\n    var _this;\n\n    _classCallCheck(this, ParameterError);\n\n    _this = _super.call(this, 'Missing required parameters', \"Missing required parameters: \" + JSON.stringify(missing, null, 2));\n    _this.expected = expected;\n    _this.actual = actual;\n    _this.missing = missing;\n    return _this;\n  }\n\n  return ParameterError;\n}(BaseError);\n\nexport { ParameterError as default };\nexport function apply(rules, values) {\n  var _rules$whitelist = rules.whitelist,\n      whitelist = _rules$whitelist === void 0 ? true : _rules$whitelist,\n      parameters = rules.parameters,\n      _rules$aliases = rules.aliases,\n      aliases = _rules$aliases === void 0 ? {} : _rules$aliases;\n  var mapped = {};\n  var requiredKeys = Object.keys(parameters).filter(function (key) {\n    return parameters[key].required;\n  }).map(function (key) {\n    return parameters[key].toName || key;\n  });\n\n  for (var _i = 0, _Object$keys = Object.keys(values); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var value = values[key];\n    var parameterKey = aliases[key] || key;\n    var parameter = parameters[parameterKey];\n\n    if (parameter && value) {\n      mapped[parameter.toName || parameterKey] = value;\n    } else if (value && !whitelist) {\n      mapped[key] = value;\n    }\n  }\n\n  var missing = requiredKeys.filter(function (key) {\n    return !mapped[key];\n  });\n\n  if (missing.length > 0) {\n    throw new ParameterError(requiredKeys, values, missing);\n  }\n\n  return mapped;\n}","map":{"version":3,"sources":["/Users/sokolowski/Documents/Private Repositories/YachtmanMobile/node_modules/react-native-auth0/src/utils/whitelist.js"],"names":["BaseError","ParameterError","expected","actual","missing","JSON","stringify","apply","rules","values","whitelist","parameters","aliases","mapped","requiredKeys","Object","keys","filter","key","required","map","toName","value","parameterKey","parameter","length"],"mappings":";;;;;;;;;AAAA,OAAOA,SAAP;;IAEqBC,c;;;;;AACnB,0BAAYC,QAAZ,EAAsBC,MAAtB,EAA8BC,OAA9B,EAAuC;AAAA;;AAAA;;AACrC,8BACE,6BADF,oCAEkCC,IAAI,CAACC,SAAL,CAAeF,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAFlC;AAIA,UAAKF,QAAL,GAAgBA,QAAhB;AACA,UAAKC,MAAL,GAAcA,MAAd;AACA,UAAKC,OAAL,GAAeA,OAAf;AAPqC;AAQtC;;;EATyCJ,S;;SAAvBC,c;AAYrB,OAAO,SAASM,KAAT,CAAeC,KAAf,EAAsBC,MAAtB,EAA8B;AAAA,yBACoBD,KADpB,CAC3BE,SAD2B;AAAA,MAC3BA,SAD2B,iCACf,IADe;AAAA,MACTC,UADS,GACoBH,KADpB,CACTG,UADS;AAAA,uBACoBH,KADpB,CACGI,OADH;AAAA,MACGA,OADH,+BACa,EADb;AAEnC,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAYL,UAAZ,EAChBM,MADgB,CACT,UAAAC,GAAG;AAAA,WAAIP,UAAU,CAACO,GAAD,CAAV,CAAgBC,QAApB;AAAA,GADM,EAEhBC,GAFgB,CAEZ,UAAAF,GAAG;AAAA,WAAIP,UAAU,CAACO,GAAD,CAAV,CAAgBG,MAAhB,IAA0BH,GAA9B;AAAA,GAFS,CAAnB;;AAGA,kCAAgBH,MAAM,CAACC,IAAP,CAAYP,MAAZ,CAAhB,kCAAqC;AAAhC,QAAIS,GAAG,mBAAP;AACH,QAAII,KAAK,GAAGb,MAAM,CAACS,GAAD,CAAlB;AACA,QAAIK,YAAY,GAAGX,OAAO,CAACM,GAAD,CAAP,IAAgBA,GAAnC;AACA,QAAIM,SAAS,GAAGb,UAAU,CAACY,YAAD,CAA1B;;AACA,QAAIC,SAAS,IAAIF,KAAjB,EAAwB;AACtBT,MAAAA,MAAM,CAACW,SAAS,CAACH,MAAV,IAAoBE,YAArB,CAAN,GAA2CD,KAA3C;AACD,KAFD,MAEO,IAAIA,KAAK,IAAI,CAACZ,SAAd,EAAyB;AAC9BG,MAAAA,MAAM,CAACK,GAAD,CAAN,GAAcI,KAAd;AACD;AACF;;AACD,MAAIlB,OAAO,GAAGU,YAAY,CAACG,MAAb,CAAoB,UAAAC,GAAG;AAAA,WAAI,CAACL,MAAM,CAACK,GAAD,CAAX;AAAA,GAAvB,CAAd;;AACA,MAAId,OAAO,CAACqB,MAAR,GAAiB,CAArB,EAAwB;AACtB,UAAM,IAAIxB,cAAJ,CAAmBa,YAAnB,EAAiCL,MAAjC,EAAyCL,OAAzC,CAAN;AACD;;AACD,SAAOS,MAAP;AACD","sourcesContent":["import BaseError from './baseError';\n\nexport default class ParameterError extends BaseError {\n  constructor(expected, actual, missing) {\n    super(\n      'Missing required parameters',\n      `Missing required parameters: ${JSON.stringify(missing, null, 2)}`\n    );\n    this.expected = expected;\n    this.actual = actual;\n    this.missing = missing;\n  }\n}\n\nexport function apply(rules, values) {\n  const { whitelist = true, parameters, aliases = {} } = rules;\n  let mapped = {};\n  let requiredKeys = Object.keys(parameters)\n    .filter(key => parameters[key].required)\n    .map(key => parameters[key].toName || key);\n  for (let key of Object.keys(values)) {\n    let value = values[key];\n    let parameterKey = aliases[key] || key;\n    let parameter = parameters[parameterKey];\n    if (parameter && value) {\n      mapped[parameter.toName || parameterKey] = value;\n    } else if (value && !whitelist) {\n      mapped[key] = value;\n    }\n  }\n  let missing = requiredKeys.filter(key => !mapped[key]);\n  if (missing.length > 0) {\n    throw new ParameterError(requiredKeys, values, missing);\n  }\n  return mapped;\n}\n"]},"metadata":{},"sourceType":"module"}