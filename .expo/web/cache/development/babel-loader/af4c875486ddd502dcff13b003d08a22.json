{"ast":null,"code":"import AuthError from \"../auth/authError\";\nimport { verifySignature } from \"./signatureVerifier\";\nvar DEFAULT_LEEWAY = 60;\nexport var verifyToken = function verifyToken(idToken, options) {\n  if (typeof idToken !== 'string') {\n    return Promise.resolve();\n  }\n\n  return verifySignature(idToken, {\n    domain: options.domain\n  }).then(function (payload) {\n    return validateClaims(payload, options);\n  }).then(function () {\n    return Promise.resolve();\n  });\n};\n\nvar validateClaims = function validateClaims(payload, opts) {\n  if (typeof payload.iss !== 'string') {\n    return Promise.reject(idTokenError({\n      error: 'missing_issuer_claim',\n      desc: 'Issuer (iss) claim must be a string present in the ID token'\n    }));\n  }\n\n  if (payload.iss !== 'https://' + opts.domain + '/') {\n    return Promise.reject(idTokenError({\n      error: 'invalid_issuer_claim',\n      desc: \"Issuer (iss) claim mismatch in the ID token; expected \\\"https://\" + opts.domain + \"/\\\", found \\\"\" + payload.iss + \"\\\"\"\n    }));\n  }\n\n  if (typeof payload.sub !== 'string') {\n    return Promise.reject(idTokenError({\n      error: 'missing_subject_claim',\n      desc: 'Subject (sub) claim must be a string present in the ID token'\n    }));\n  }\n\n  if (!(typeof payload.aud === 'string' || Array.isArray(payload.aud))) {\n    return Promise.reject(idTokenError({\n      error: 'missing_audience_claim',\n      desc: 'Audience (aud) claim must be a string or array of strings present in the ID token'\n    }));\n  }\n\n  if (Array.isArray(payload.aud) && !payload.aud.includes(opts.clientId)) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_audience_claim',\n      desc: \"Audience (aud) claim mismatch in the ID token; expected \\\"\" + opts.clientId + \"\\\" but was not one of \\\"\" + payload.aud.join(', ') + \"\\\"\"\n    }));\n  } else if (typeof payload.aud === 'string' && payload.aud !== opts.clientId) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_audience_claim',\n      desc: \"Audience (aud) claim mismatch in the ID token; expected \\\"\" + opts.clientId + \"\\\" but found \\\"\" + payload.aud + \"\\\"\"\n    }));\n  }\n\n  var now = opts._clock ? getEpochTimeInSeconds(opts._clock) : getEpochTimeInSeconds(new Date());\n  var leeway = typeof opts.leeway === 'number' ? opts.leeway : DEFAULT_LEEWAY;\n\n  if (typeof payload.exp !== 'number') {\n    return Promise.reject(idTokenError({\n      error: 'missing_expires_at_claim',\n      desc: 'Expiration Time (exp) claim must be a number present in the ID token'\n    }));\n  }\n\n  var expTime = payload.exp + leeway;\n\n  if (now > expTime) {\n    return Promise.reject(idTokenError({\n      error: 'invalid_expires_at_claim',\n      desc: \"Expiration Time (exp) claim error in the ID token; current time \\\"\" + now + \"\\\" is after expiration time \\\"\" + expTime + \"\\\"\"\n    }));\n  }\n\n  if (typeof payload.iat !== 'number') {\n    return Promise.reject(idTokenError({\n      error: 'missing_issued_at_claim',\n      desc: 'Issued At (iat) claim must be a number present in the ID token'\n    }));\n  }\n\n  if (opts.nonce) {\n    if (typeof payload.nonce !== 'string') {\n      return Promise.reject(idTokenError({\n        error: 'missing_nonce_claim',\n        desc: 'Nonce (nonce) claim must be a string present in the ID token'\n      }));\n    }\n\n    if (payload.nonce !== opts.nonce) {\n      return Promise.reject(idTokenError({\n        error: 'invalid_nonce_claim',\n        desc: \"Nonce (nonce) claim mismatch in the ID token; expected \\\"\" + opts.nonce + \"\\\", found \\\"\" + payload.nonce + \"\\\"\"\n      }));\n    }\n  }\n\n  if (Array.isArray(payload.aud) && payload.aud.length > 1) {\n    if (typeof payload.azp !== 'string') {\n      return Promise.reject(idTokenError({\n        error: 'missing_authorized_party_claim',\n        desc: 'Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values'\n      }));\n    }\n\n    if (payload.azp !== opts.clientId) {\n      return Promise.reject(idTokenError({\n        error: 'invalid_authorized_party_claim',\n        desc: \"Authorized Party (azp) claim mismatch in the ID token; expected \\\"\" + opts.clientId + \"\\\", found \\\"\" + payload.azp + \"\\\"\"\n      }));\n    }\n  }\n\n  if (typeof opts.maxAge === 'number') {\n    if (typeof payload.auth_time !== 'number') {\n      return Promise.reject(idTokenError({\n        error: 'missing_authorization_time_claim',\n        desc: 'Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified'\n      }));\n    }\n\n    var authValidUntil = payload.auth_time + opts.maxAge + leeway;\n\n    if (now > authValidUntil) {\n      return Promise.reject(idTokenError({\n        error: 'invalid_authorization_time_claim',\n        desc: \"Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time \\\"\" + now + \"\\\" is after last auth time \\\"\" + authValidUntil + \"\\\"\"\n      }));\n    }\n  }\n\n  return Promise.resolve();\n};\n\nvar getEpochTimeInSeconds = function getEpochTimeInSeconds(date) {\n  return Math.round(date.getTime() / 1000);\n};\n\nvar idTokenError = function idTokenError() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$error = _ref.error,\n      error = _ref$error === void 0 ? 'verification_error' : _ref$error,\n      _ref$desc = _ref.desc,\n      desc = _ref$desc === void 0 ? 'Error verifying ID token' : _ref$desc;\n\n  return new AuthError({\n    json: {\n      error: \"a0.idtoken.\" + error,\n      error_description: desc\n    },\n    status: 0\n  });\n};","map":{"version":3,"sources":["/Users/sokolowski/Documents/Private Repositories/YachtmanMobile/node_modules/react-native-auth0/src/jwt/validator.js"],"names":["AuthError","verifySignature","DEFAULT_LEEWAY","verifyToken","idToken","options","Promise","resolve","domain","then","payload","validateClaims","opts","iss","reject","idTokenError","error","desc","sub","aud","Array","isArray","includes","clientId","join","now","_clock","getEpochTimeInSeconds","Date","leeway","exp","expTime","iat","nonce","length","azp","maxAge","auth_time","authValidUntil","date","Math","round","getTime","json","error_description","status"],"mappings":"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","sourcesContent":["import AuthError from '../auth/authError';\nimport {verifySignature} from './signatureVerifier';\n\n// default clock skew, in seconds\nconst DEFAULT_LEEWAY = 60;\n\n/**\n * Verifies an ID token according to the OIDC specification. Note that this function is specific to the internals of this SDK,\n * and is not supported for general use.\n * @param {String} idToken the string token to verify\n * @param {Object}options the options required to run this verification\n * @returns {Promise} A promise that resolves if the verification is successful, or will reject the promise if validation fails\n */\nexport const verifyToken = (idToken, options) => {\n  if (typeof idToken !== 'string') {\n    return Promise.resolve();\n  }\n\n  return verifySignature(idToken, {domain: options.domain})\n    .then(payload => validateClaims(payload, options))\n    .then(() => Promise.resolve());\n};\n\nconst validateClaims = (payload, opts) => {\n  // Issuer\n  if (typeof payload.iss !== 'string') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_issuer_claim',\n        desc: 'Issuer (iss) claim must be a string present in the ID token',\n      }),\n    );\n  }\n\n  if (payload.iss !== 'https://' + opts.domain + '/') {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_issuer_claim',\n        desc: `Issuer (iss) claim mismatch in the ID token; expected \"https://${opts.domain}/\", found \"${payload.iss}\"`,\n      }),\n    );\n  }\n\n  // Subject\n  if (typeof payload.sub !== 'string') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_subject_claim',\n        desc: 'Subject (sub) claim must be a string present in the ID token',\n      }),\n    );\n  }\n\n  // Audience\n  if (!(typeof payload.aud === 'string' || Array.isArray(payload.aud))) {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_audience_claim',\n        desc:\n          'Audience (aud) claim must be a string or array of strings present in the ID token',\n      }),\n    );\n  }\n\n  if (Array.isArray(payload.aud) && !payload.aud.includes(opts.clientId)) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_audience_claim',\n        desc: `Audience (aud) claim mismatch in the ID token; expected \"${\n          opts.clientId\n        }\" but was not one of \"${payload.aud.join(', ')}\"`,\n      }),\n    );\n  } else if (typeof payload.aud === 'string' && payload.aud !== opts.clientId) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_audience_claim',\n        desc: `Audience (aud) claim mismatch in the ID token; expected \"${opts.clientId}\" but found \"${payload.aud}\"`,\n      }),\n    );\n  }\n\n  //--Time validation (epoch)--\n  const now = opts._clock\n    ? getEpochTimeInSeconds(opts._clock)\n    : getEpochTimeInSeconds(new Date());\n  const leeway = typeof opts.leeway === 'number' ? opts.leeway : DEFAULT_LEEWAY;\n\n  //Expires at\n  if (typeof payload.exp !== 'number') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_expires_at_claim',\n        desc:\n          'Expiration Time (exp) claim must be a number present in the ID token',\n      }),\n    );\n  }\n\n  const expTime = payload.exp + leeway;\n\n  if (now > expTime) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_expires_at_claim',\n        desc: `Expiration Time (exp) claim error in the ID token; current time \"${now}\" is after expiration time \"${expTime}\"`,\n      }),\n    );\n  }\n\n  //Issued at\n  if (typeof payload.iat !== 'number') {\n    return Promise.reject(\n      idTokenError({\n        error: 'missing_issued_at_claim',\n        desc: 'Issued At (iat) claim must be a number present in the ID token',\n      }),\n    );\n  }\n\n  //Nonce\n  if (opts.nonce) {\n    if (typeof payload.nonce !== 'string') {\n      return Promise.reject(\n        idTokenError({\n          error: 'missing_nonce_claim',\n          desc: 'Nonce (nonce) claim must be a string present in the ID token',\n        }),\n      );\n    }\n    if (payload.nonce !== opts.nonce) {\n      return Promise.reject(\n        idTokenError({\n          error: 'invalid_nonce_claim',\n          desc: `Nonce (nonce) claim mismatch in the ID token; expected \"${opts.nonce}\", found \"${payload.nonce}\"`,\n        }),\n      );\n    }\n  }\n\n  //Authorized party\n  if (Array.isArray(payload.aud) && payload.aud.length > 1) {\n    if (typeof payload.azp !== 'string') {\n      return Promise.reject(\n        idTokenError({\n          error: 'missing_authorized_party_claim',\n          desc:\n            'Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values',\n        }),\n      );\n    }\n\n    if (payload.azp !== opts.clientId) {\n      return Promise.reject(\n        idTokenError({\n          error: 'invalid_authorized_party_claim',\n          desc: `Authorized Party (azp) claim mismatch in the ID token; expected \"${opts.clientId}\", found \"${payload.azp}\"`,\n        }),\n      );\n    }\n  }\n\n  //Authentication time\n  if (typeof opts.maxAge === 'number') {\n    if (typeof payload.auth_time !== 'number') {\n      return Promise.reject(\n        idTokenError({\n          error: 'missing_authorization_time_claim',\n          desc:\n            'Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified',\n        }),\n      );\n    }\n\n    const authValidUntil = payload.auth_time + opts.maxAge + leeway;\n\n    if (now > authValidUntil) {\n      return Promise.reject(\n        idTokenError({\n          error: 'invalid_authorization_time_claim',\n          desc: `Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time \"${now}\" is after last auth time \"${authValidUntil}\"`,\n        }),\n      );\n    }\n  }\n\n  return Promise.resolve();\n};\n\nconst getEpochTimeInSeconds = date => {\n  return Math.round(date.getTime() / 1000);\n};\n\nconst idTokenError = ({\n  error = 'verification_error',\n  desc = 'Error verifying ID token',\n} = {}) => {\n  return new AuthError({\n    json: {\n      error: `a0.idtoken.${error}`,\n      error_description: desc,\n    },\n    status: 0,\n  });\n};\n"]},"metadata":{},"sourceType":"module"}