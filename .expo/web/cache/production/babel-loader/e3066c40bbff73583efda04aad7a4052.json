{"ast":null,"code":"import AuthError from\"../auth/authError\";import RSAVerifier from\"./rsa-verifier\";import*as base64 from\"./base64\";var jwtDecoder=require('jwt-decode');var ALLOWED_ALGORITHMS=['RS256','HS256'];export var verifySignature=function verifySignature(idToken,options){var header,payload;try{header=jwtDecoder(idToken,{header:true});payload=jwtDecoder(idToken);}catch(err){return Promise.reject(idTokenError({error:'token_decoding_error',desc:'ID token could not be decoded'}));}var alg=header.alg;if(!ALLOWED_ALGORITHMS.includes(alg)){return Promise.reject(idTokenError({error:'invalid_algorithm',desc:\"Signature algorithm of \\\"\"+alg+\"\\\" is not supported. Expected \\\"RS256\\\" or \\\"HS256\\\".\"}));}if(alg==='HS256'){return Promise.resolve(payload);}return getJwk(options.domain,header.kid).then(function(jwk){var rsaVerifier=rsaVerifierForKey(jwk);var encodedParts=idToken.split('.');var headerAndPayload=encodedParts[0]+'.'+encodedParts[1];var signature=base64.decodeToHEX(encodedParts[2]);if(rsaVerifier.verify(headerAndPayload,signature)){return Promise.resolve(payload);}return Promise.reject(idTokenError({error:'invalid_signature',desc:'Invalid ID token signature'}));});};var rsaVerifierForKey=function rsaVerifierForKey(jwk){var modulus=base64.decodeToHEX(jwk.n);var exponent=base64.decodeToHEX(jwk.e);return new RSAVerifier(modulus,exponent);};var getJwk=function getJwk(domain,kid){return getJwksUri(domain).then(function(uri){return fetchJson(uri);}).then(function(jwk){var keys=jwk.keys;var key=keys.filter(function(k){return k.use==='sig'&&k.kty==='RSA'&&k.kid&&k.n&&k.e;}).find(function(k){return k.kid===kid;});if(!key){throw new Error('Key not present');}return Promise.resolve(key);}).catch(function(err){return Promise.reject(idTokenError({error:'key_retrieval_error',desc:\"Could not find a public key for Key ID (kid) \\\"\"+kid+\"\\\"\"}));});};var getJwksUri=function getJwksUri(domain){return fetch(\"https://\"+domain+\"/.well-known/openid-configuration\").then(function(resp){return resp.json();}).then(function(openIdConfig){return openIdConfig.jwks_uri;});};var fetchJson=function fetchJson(uri){return fetch(uri).then(function(resp){return resp.json();});};var idTokenError=function idTokenError(err){return new AuthError({json:{error:\"a0.idtoken.\"+err.error,error_description:err.desc},status:0});};","map":{"version":3,"sources":["/Users/sokolowski/Documents/Private Repositories/YachtmanMobile/node_modules/react-native-auth0/src/jwt/signatureVerifier.js"],"names":["AuthError","RSAVerifier","base64","jwtDecoder","require","ALLOWED_ALGORITHMS","verifySignature","idToken","options","header","payload","err","Promise","reject","idTokenError","error","desc","alg","includes","resolve","getJwk","domain","kid","then","jwk","rsaVerifier","rsaVerifierForKey","encodedParts","split","headerAndPayload","signature","decodeToHEX","verify","modulus","n","exponent","e","getJwksUri","uri","fetchJson","keys","key","filter","k","use","kty","find","Error","catch","fetch","resp","json","openIdConfig","jwks_uri","error_description","status"],"mappings":"AAAA,MAAOA,CAAAA,SAAP,yBACA,MAAOC,CAAAA,WAAP,sBACA,MAAO,GAAKC,CAAAA,MAAZ,gBACA,GAAMC,CAAAA,UAAU,CAAGC,OAAO,CAAC,YAAD,CAA1B,CAEA,GAAMC,CAAAA,kBAAkB,CAAG,CAAC,OAAD,CAAU,OAAV,CAA3B,CAUA,MAAO,IAAMC,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAACC,OAAD,CAAUC,OAAV,CAAsB,CACnD,GAAIC,CAAAA,MAAJ,CAAYC,OAAZ,CAEA,GAAI,CACFD,MAAM,CAAGN,UAAU,CAACI,OAAD,CAAU,CAACE,MAAM,CAAE,IAAT,CAAV,CAAnB,CACAC,OAAO,CAAGP,UAAU,CAACI,OAAD,CAApB,CACD,CAAC,MAAOI,GAAP,CAAY,CACZ,MAAOC,CAAAA,OAAO,CAACC,MAAR,CACLC,YAAY,CAAC,CACXC,KAAK,CAAE,sBADI,CAEXC,IAAI,CAAE,+BAFK,CAAD,CADP,CAAP,CAMD,CAED,GAAMC,CAAAA,GAAG,CAAGR,MAAM,CAACQ,GAAnB,CAEA,GAAI,CAACZ,kBAAkB,CAACa,QAAnB,CAA4BD,GAA5B,CAAL,CAAuC,CACrC,MAAOL,CAAAA,OAAO,CAACC,MAAR,CACLC,YAAY,CAAC,CACXC,KAAK,CAAE,mBADI,CAEXC,IAAI,6BAA6BC,GAA7B,wDAFO,CAAD,CADP,CAAP,CAMD,CAID,GAAIA,GAAG,GAAK,OAAZ,CAAqB,CACnB,MAAOL,CAAAA,OAAO,CAACO,OAAR,CAAgBT,OAAhB,CAAP,CACD,CAED,MAAOU,CAAAA,MAAM,CAACZ,OAAO,CAACa,MAAT,CAAiBZ,MAAM,CAACa,GAAxB,CAAN,CAAmCC,IAAnC,CAAwC,SAAAC,GAAG,CAAI,CACpD,GAAMC,CAAAA,WAAW,CAAGC,iBAAiB,CAACF,GAAD,CAArC,CACA,GAAMG,CAAAA,YAAY,CAAGpB,OAAO,CAACqB,KAAR,CAAc,GAAd,CAArB,CACA,GAAMC,CAAAA,gBAAgB,CAAGF,YAAY,CAAC,CAAD,CAAZ,CAAkB,GAAlB,CAAwBA,YAAY,CAAC,CAAD,CAA7D,CACA,GAAMG,CAAAA,SAAS,CAAG5B,MAAM,CAAC6B,WAAP,CAAmBJ,YAAY,CAAC,CAAD,CAA/B,CAAlB,CACA,GAAIF,WAAW,CAACO,MAAZ,CAAmBH,gBAAnB,CAAqCC,SAArC,CAAJ,CAAqD,CACnD,MAAOlB,CAAAA,OAAO,CAACO,OAAR,CAAgBT,OAAhB,CAAP,CACD,CACD,MAAOE,CAAAA,OAAO,CAACC,MAAR,CACLC,YAAY,CAAC,CACXC,KAAK,CAAE,mBADI,CAEXC,IAAI,CAAE,4BAFK,CAAD,CADP,CAAP,CAMD,CAdM,CAAP,CAeD,CA/CM,CAiDP,GAAMU,CAAAA,iBAAiB,CAAG,QAApBA,CAAAA,iBAAoB,CAAAF,GAAG,CAAI,CAC/B,GAAMS,CAAAA,OAAO,CAAG/B,MAAM,CAAC6B,WAAP,CAAmBP,GAAG,CAACU,CAAvB,CAAhB,CACA,GAAMC,CAAAA,QAAQ,CAAGjC,MAAM,CAAC6B,WAAP,CAAmBP,GAAG,CAACY,CAAvB,CAAjB,CACA,MAAO,IAAInC,CAAAA,WAAJ,CAAgBgC,OAAhB,CAAyBE,QAAzB,CAAP,CACD,CAJD,CAMA,GAAMf,CAAAA,MAAM,CAAG,QAATA,CAAAA,MAAS,CAACC,MAAD,CAASC,GAAT,CAAiB,CAC9B,MAAOe,CAAAA,UAAU,CAAChB,MAAD,CAAV,CACJE,IADI,CACC,SAAAe,GAAG,QAAIC,CAAAA,SAAS,CAACD,GAAD,CAAb,EADJ,EAEJf,IAFI,CAEC,SAAAC,GAAG,CAAI,CACX,GAAMgB,CAAAA,IAAI,CAAGhB,GAAG,CAACgB,IAAjB,CACA,GAAMC,CAAAA,GAAG,CAAGD,IAAI,CACbE,MADS,CAER,SAAAC,CAAC,QAAIA,CAAAA,CAAC,CAACC,GAAF,GAAU,KAAV,EAAmBD,CAAC,CAACE,GAAF,GAAU,KAA7B,EAAsCF,CAAC,CAACrB,GAAxC,EAAgDqB,CAAC,CAACT,CAAF,EAAOS,CAAC,CAACP,CAA7D,EAFO,EAITU,IAJS,CAIJ,SAAAH,CAAC,QAAIA,CAAAA,CAAC,CAACrB,GAAF,GAAUA,GAAd,EAJG,CAAZ,CAKA,GAAI,CAACmB,GAAL,CAAU,CACR,KAAM,IAAIM,CAAAA,KAAJ,CAAU,iBAAV,CAAN,CACD,CACD,MAAOnC,CAAAA,OAAO,CAACO,OAAR,CAAgBsB,GAAhB,CAAP,CACD,CAbI,EAcJO,KAdI,CAcE,SAAArC,GAAG,CAAI,CACZ,MAAOC,CAAAA,OAAO,CAACC,MAAR,CACLC,YAAY,CAAC,CACXC,KAAK,CAAE,qBADI,CAEXC,IAAI,mDAAmDM,GAAnD,KAFO,CAAD,CADP,CAAP,CAMD,CArBI,CAAP,CAsBD,CAvBD,CAyBA,GAAMe,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAAAhB,MAAM,CAAI,CAC3B,MAAO4B,CAAAA,KAAK,YAAY5B,MAAZ,qCAAL,CACJE,IADI,CACC,SAAA2B,IAAI,QAAIA,CAAAA,IAAI,CAACC,IAAL,EAAJ,EADL,EAEJ5B,IAFI,CAEC,SAAA6B,YAAY,QAAIA,CAAAA,YAAY,CAACC,QAAjB,EAFb,CAAP,CAGD,CAJD,CAMA,GAAMd,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAAAD,GAAG,CAAI,CACvB,MAAOW,CAAAA,KAAK,CAACX,GAAD,CAAL,CAAWf,IAAX,CAAgB,SAAA2B,IAAI,QAAIA,CAAAA,IAAI,CAACC,IAAL,EAAJ,EAApB,CAAP,CACD,CAFD,CAIA,GAAMrC,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAAAH,GAAG,CAAI,CAC1B,MAAO,IAAIX,CAAAA,SAAJ,CAAc,CACnBmD,IAAI,CAAE,CACJpC,KAAK,eAAgBJ,GAAG,CAACI,KADrB,CAEJuC,iBAAiB,CAAE3C,GAAG,CAACK,IAFnB,CADa,CAKnBuC,MAAM,CAAE,CALW,CAAd,CAAP,CAOD,CARD","sourcesContent":["import AuthError from '../auth/authError';\nimport RSAVerifier from './rsa-verifier';\nimport * as base64 from './base64';\nconst jwtDecoder = require('jwt-decode');\n\nconst ALLOWED_ALGORITHMS = ['RS256', 'HS256'];\n\n/**\n * Verifies that an ID token is signed with a supported algorithm (HS256 or RS256), and verifies the signature\n * if signed with RS256. Note that this function is specific to the internals of this SDK, and not supported for general use.\n * @param {String} idToken the ID token\n * @param {Object} options required to verify an ID token's signature\n * @param {String} [options.domain] the Auth0 domain of the token's issuer\n * @returns {Promise} A promise that resolves to the decoded payload of the ID token, or rejects if the verification fails.\n */\nexport const verifySignature = (idToken, options) => {\n  let header, payload;\n\n  try {\n    header = jwtDecoder(idToken, {header: true});\n    payload = jwtDecoder(idToken);\n  } catch (err) {\n    return Promise.reject(\n      idTokenError({\n        error: 'token_decoding_error',\n        desc: 'ID token could not be decoded',\n      }),\n    );\n  }\n\n  const alg = header.alg;\n\n  if (!ALLOWED_ALGORITHMS.includes(alg)) {\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_algorithm',\n        desc: `Signature algorithm of \"${alg}\" is not supported. Expected \"RS256\" or \"HS256\".`,\n      }),\n    );\n  }\n\n  // HS256 tokens require private key, which cannot be stored securely in public clients.\n  // Since the ID token exchange is done via CODE with PKCE flow, we can skip signature verification in this case.\n  if (alg === 'HS256') {\n    return Promise.resolve(payload);\n  }\n\n  return getJwk(options.domain, header.kid).then(jwk => {\n    const rsaVerifier = rsaVerifierForKey(jwk);\n    const encodedParts = idToken.split('.');\n    const headerAndPayload = encodedParts[0] + '.' + encodedParts[1];\n    const signature = base64.decodeToHEX(encodedParts[2]);\n    if (rsaVerifier.verify(headerAndPayload, signature)) {\n      return Promise.resolve(payload);\n    }\n    return Promise.reject(\n      idTokenError({\n        error: 'invalid_signature',\n        desc: 'Invalid ID token signature',\n      }),\n    );\n  });\n};\n\nconst rsaVerifierForKey = jwk => {\n  const modulus = base64.decodeToHEX(jwk.n);\n  const exponent = base64.decodeToHEX(jwk.e);\n  return new RSAVerifier(modulus, exponent);\n};\n\nconst getJwk = (domain, kid) => {\n  return getJwksUri(domain)\n    .then(uri => fetchJson(uri))\n    .then(jwk => {\n      const keys = jwk.keys;\n      const key = keys\n        .filter(\n          k => k.use === 'sig' && k.kty === 'RSA' && k.kid && (k.n && k.e),\n        )\n        .find(k => k.kid === kid);\n      if (!key) {\n        throw new Error('Key not present');\n      }\n      return Promise.resolve(key);\n    })\n    .catch(err => {\n      return Promise.reject(\n        idTokenError({\n          error: 'key_retrieval_error',\n          desc: `Could not find a public key for Key ID (kid) \"${kid}\"`,\n        }),\n      );\n    });\n};\n\nconst getJwksUri = domain => {\n  return fetch(`https://${domain}/.well-known/openid-configuration`)\n    .then(resp => resp.json())\n    .then(openIdConfig => openIdConfig.jwks_uri);\n};\n\nconst fetchJson = uri => {\n  return fetch(uri).then(resp => resp.json());\n};\n\nconst idTokenError = err => {\n  return new AuthError({\n    json: {\n      error: `a0.idtoken.${err.error}`,\n      error_description: err.desc,\n    },\n    status: 0,\n  });\n};\n"]},"metadata":{},"sourceType":"module"}