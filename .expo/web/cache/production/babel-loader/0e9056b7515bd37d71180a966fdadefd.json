{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{Platform}from'@unimodules/core';import Constants from'expo-constants';import*as Linking from'expo-linking';import{dismissAuthSession,openAuthSessionAsync}from'expo-web-browser';import{AuthRequest}from\"./AuthRequest\";import{CodeChallengeMethod,Prompt,ResponseType}from\"./AuthRequest.types\";import{fetchDiscoveryAsync,resolveDiscoveryAsync}from\"./Discovery\";import{generateHexStringAsync}from\"./PKCE\";import{getQueryParams}from\"./QueryParams\";import{getSessionUrlProvider}from\"./SessionUrlProvider\";var _authLock=false;var sessionUrlProvider=getSessionUrlProvider();export function startAsync(options){var returnUrl,authUrl,startUrl,showInRecents,result,_getQueryParams,params,errorCode;return _regeneratorRuntime.async(function startAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:returnUrl=options.returnUrl||sessionUrlProvider.getDefaultReturnUrl();authUrl=options.authUrl;startUrl=sessionUrlProvider.getStartUrl(authUrl,returnUrl);showInRecents=options.showInRecents||false;if(authUrl){_context.next=6;break;}throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');case 6:if(!_authLock){_context.next=9;break;}if(__DEV__){console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');}return _context.abrupt(\"return\",{type:'locked'});case 9:_authLock=true;_context.prev=10;_context.next=13;return _regeneratorRuntime.awrap(_openWebBrowserAsync(startUrl,returnUrl,showInRecents));case 13:result=_context.sent;case 14:_context.prev=14;_authLock=false;return _context.finish(14);case 17:if(result){_context.next=19;break;}throw new Error('Unexpected missing AuthSession result');case 19:if(result.url){_context.next=25;break;}if(!result.type){_context.next=24;break;}return _context.abrupt(\"return\",result);case 24:throw new Error('Unexpected AuthSession result with missing type');case 25:_getQueryParams=getQueryParams(result.url),params=_getQueryParams.params,errorCode=_getQueryParams.errorCode;return _context.abrupt(\"return\",{type:errorCode?'error':'success',params:params,errorCode:errorCode,authentication:null,url:result.url});case 27:case\"end\":return _context.stop();}}},null,null,[[10,,14,17]],Promise);}export function dismiss(){dismissAuthSession();}export function getDefaultReturnUrl(){return sessionUrlProvider.getDefaultReturnUrl();}export function getRedirectUrl(path){return sessionUrlProvider.getRedirectUrl(path);}export function makeRedirectUri(){var _ref=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},native=_ref.native,path=_ref.path,preferLocalhost=_ref.preferLocalhost,useProxy=_ref.useProxy;if(Platform.OS!=='web'){if(!Constants.manifest){if(!native){console.warn(\"makeRedirectUri requires you define a `native` scheme for bare workflow, and standalone native apps, you'll need to manually define it based on your app's URI schemes.\");}return native||'';}if(Constants.appOwnership==='standalone'&&native){return native;}}if(!useProxy||Platform.OS==='web'){var url=Linking.makeUrl(path);if(preferLocalhost){var ipAddress=url.match(/\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/);if(ipAddress==null?void 0:ipAddress.length){var _url$split=url.split(ipAddress[0]),_url$split2=_slicedToArray(_url$split,2),protocol=_url$split2[0],_path=_url$split2[1];return protocol+\"localhost\"+_path;}}return url;}return sessionUrlProvider.getRedirectUrl(path);}export function loadAsync(config,issuerOrDiscovery){var request,discovery;return _regeneratorRuntime.async(function loadAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:request=new AuthRequest(config);_context2.next=3;return _regeneratorRuntime.awrap(resolveDiscoveryAsync(issuerOrDiscovery));case 3:discovery=_context2.sent;_context2.next=6;return _regeneratorRuntime.awrap(request.makeAuthUrlAsync(discovery));case 6:return _context2.abrupt(\"return\",request);case 7:case\"end\":return _context2.stop();}}},null,null,null,Promise);}function _openWebBrowserAsync(startUrl,returnUrl,showInRecents){var result;return _regeneratorRuntime.async(function _openWebBrowserAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return _regeneratorRuntime.awrap(openAuthSessionAsync(startUrl,returnUrl,{showInRecents:showInRecents}));case 2:result=_context3.sent;if(!(result.type==='cancel'||result.type==='dismiss')){_context3.next=5;break;}return _context3.abrupt(\"return\",{type:result.type});case 5:return _context3.abrupt(\"return\",result);case 6:case\"end\":return _context3.stop();}}},null,null,null,Promise);}export{useAutoDiscovery,useAuthRequest}from\"./AuthRequestHooks\";export{AuthError,TokenError}from\"./Errors\";export{AuthRequest,CodeChallengeMethod,Prompt,ResponseType,resolveDiscoveryAsync,fetchDiscoveryAsync,generateHexStringAsync};export{TokenResponse,AccessTokenRequest,RefreshTokenRequest,RevokeTokenRequest,revokeAsync,refreshAsync,exchangeCodeAsync,fetchUserInfoAsync}from\"./TokenRequest\";export*from\"./TokenRequest.types\";","map":{"version":3,"sources":["../src/AuthSession.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from '@unimodules/core';\nimport Constants from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { dismissAuthSession, openAuthSessionAsync } from 'expo-web-browser';\n\nimport { AuthRequest } from './AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  Prompt,\n  ResponseType,\n} from './AuthRequest.types';\nimport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n} from './AuthSession.types';\nimport {\n  DiscoveryDocument,\n  fetchDiscoveryAsync,\n  Issuer,\n  IssuerOrDiscovery,\n  ProviderMetadata,\n  resolveDiscoveryAsync,\n} from './Discovery';\nimport { generateHexStringAsync } from './PKCE';\nimport { getQueryParams } from './QueryParams';\nimport { getSessionUrlProvider } from './SessionUrlProvider';\n\nlet _authLock = false;\nconst sessionUrlProvider = getSessionUrlProvider();\n\nexport async function startAsync(options: AuthSessionOptions): Promise<AuthSessionResult> {\n  const returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n  const authUrl = options.authUrl;\n  const startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl);\n  const showInRecents = options.showInRecents || false;\n\n  // Prevent accidentally starting to an empty url\n  if (!authUrl) {\n    throw new Error(\n      'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n    );\n  }\n\n  // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n      );\n    }\n\n    return { type: 'locked' };\n  }\n\n  // About to start session, set lock\n  _authLock = true;\n\n  let result;\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  }\n\n  // Handle failures\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n  if (!result.url) {\n    if (result.type) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  const { params, errorCode } = getQueryParams(result.url);\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    authentication: null,\n    url: result.url,\n  };\n}\n\nexport function dismiss() {\n  dismissAuthSession();\n}\n\nexport function getDefaultReturnUrl(): string {\n  return sessionUrlProvider.getDefaultReturnUrl();\n}\n\n/**\n * @deprecated Use `makeRedirectUri({ path, useProxy })` instead.\n *\n * @param path\n */\nexport function getRedirectUrl(path?: string): string {\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Create a redirect url for the current platform.\n * - **Web:** Generates a path based on the current \\`window.location\\`. For production web apps you should hard code the URL.\n * - **Managed, and Custom workflow:** Uses the `scheme` property of your `app.config.js` or `app.json`.\n *   - **Proxy:** Uses auth.expo.io as the base URL for the path. This only works in Expo client and standalone environments.\n * - **Bare workflow:** Will fallback to using the `native` option for bare workflow React Native apps.\n *\n * @param options Additional options for configuring the path.\n */\nexport function makeRedirectUri({\n  native,\n  path,\n  preferLocalhost,\n  useProxy,\n}: AuthSessionRedirectUriOptions = {}): string {\n  if (Platform.OS !== 'web') {\n    // Bare workflow\n    if (!Constants.manifest) {\n      if (!native) {\n        // TODO(Bacon): Link to docs or fyi\n        console.warn(\n          \"makeRedirectUri requires you define a `native` scheme for bare workflow, and standalone native apps, you'll need to manually define it based on your app's URI schemes.\"\n        );\n      }\n      // Returning an empty string makes types easier to work with.\n      // Server will throw an error about the invalid URI scheme.\n      return native || '';\n    }\n    // Should use the user-defined native scheme in standalone builds\n    if (Constants.appOwnership === 'standalone' && native) {\n      return native;\n    }\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    const url = Linking.makeUrl(path);\n\n    if (preferLocalhost) {\n      const ipAddress = url.match(\n        /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/\n      );\n      // Only replace if an IP address exists\n      if (ipAddress?.length) {\n        const [protocol, path] = url.split(ipAddress[0]);\n        return `${protocol}localhost${path}`;\n      }\n    }\n\n    return url;\n  }\n  // Attempt to use the proxy\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Build an `AuthRequest` and load it before returning.\n *\n * @param config\n * @param issuerOrDiscovery\n */\nexport async function loadAsync(\n  config: AuthRequestConfig,\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<AuthRequest> {\n  const request = new AuthRequest(config);\n  const discovery = await resolveDiscoveryAsync(issuerOrDiscovery);\n  await request.makeAuthUrlAsync(discovery);\n  return request;\n}\n\nasync function _openWebBrowserAsync(startUrl: string, returnUrl: string, showInRecents: boolean) {\n  // $FlowIssue: Flow thinks the awaited result can be a promise\n  const result = await openAuthSessionAsync(startUrl, returnUrl, { showInRecents });\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return { type: result.type };\n  }\n\n  return result;\n}\n\nexport { useAutoDiscovery, useAuthRequest } from './AuthRequestHooks';\nexport { AuthError, TokenError } from './Errors';\n\nexport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  DiscoveryDocument,\n  Issuer,\n  IssuerOrDiscovery,\n  Prompt,\n  ProviderMetadata,\n  ResponseType,\n  resolveDiscoveryAsync,\n  fetchDiscoveryAsync,\n  generateHexStringAsync,\n};\n\nexport {\n  // Token classes\n  TokenResponse,\n  AccessTokenRequest,\n  RefreshTokenRequest,\n  RevokeTokenRequest,\n  // Token methods\n  revokeAsync,\n  refreshAsync,\n  exchangeCodeAsync,\n  fetchUserInfoAsync,\n} from './TokenRequest';\n\n// Token types\nexport * from './TokenRequest.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}